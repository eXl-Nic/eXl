#include "serializer.hpp"

#include <fstream>
#include <locale>
#include <unordered_set>

#include "serializer.class.hpp"
#include "serializer.enum.hpp"
#include "serializer.function.hpp"
#include "serializer.util.hpp"

namespace eXl
{
  namespace reflang
  {
    namespace
    {
      bool IsValidCIdentifierChar(char c)
      {
        static std::locale s_curLocale("");

        return std::isalnum(static_cast<unsigned char>(c), s_curLocale) || c == '_';
      }

	    void AutoGenComment(std::ostream& o)
	    {
		    o << 
R"(// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!! This file is auto-generated by Reflang. !!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
)";
	    }

	    void BeginHeader(
			    std::ostream& o,
			    const serializer::Options& options)
	    {
		    AutoGenComment(o);

        o << "#pragma once\n";
		    //o << "#include <core/type/typetraits.hpp>\n";
        //o << "#define DEFINE_"<< options.internalLibName <<"_TYPE_EX(type, friendlyname) DEFINE_TYPE_EX(type, friendlyname, EXL_" << options.internalLibName << "_API)\n";
        //o << "#define DEFINE_"<< options.internalLibName <<"_TYPE(type) DEFINE_"<< options.internalLibName <<"_TYPE_EX(type, type)\n";
		    //o << options.include_path << "\n";

        o << "namespace eXl\n";
        o << "{\n";
        //o << "EXL_" << options.internalLibName << "_API ";
        o << "void Register_" << options.internalLibName << "_Types();";
	    }

	    void EndHeader(
			    std::ostream& o,
			    const serializer::Options& options)
	    {
		    o << "}";
	    }

	    void BeginSources(std::ostream& o, const serializer::Options& options, const Vector<std::unique_ptr<TypeBase>>& types)
	    {
		    AutoGenComment(o);

        // Generate unique list of includes.
        UnorderedSet<String> headers;
        for (const auto& type : types)
        {
          headers.insert(type->GetFile().string().c_str());
        }
        for (const auto& header : headers)
        {
          o << "#include \"" << header << "\"\n";
        }

        String lowercaseLibName = options.internalLibName;
        std::transform(lowercaseLibName.begin(), lowercaseLibName.end(), lowercaseLibName.begin(),
          [](char c) { return tolower(c); });
        //o << "#include <" << lowercaseLibName << "/" << lowercaseLibName << "lib.hpp>\n";
        o << "#include <core/type/typemanager.hpp>\n";
        o << "#include <core/type/tupletypestruct.hpp>\n";
        o << "#include <core/type/arraytype.hpp>\n";
        o << "#include <core/type/enumtype.hpp>\n";
#ifdef EXL_LUA
        o << "#include <core/lua/luamanager.hpp>\n";
        o << "#include <luabind/luabind.hpp>\n";
#endif
		    if (!options.out_hpp_path.empty())
		    {
			    o << "#include \"" << options.out_hpp_path << "\"\n";
		    }
        o << "namespace eXl\n{\n";
	    }

	    void EndSources(std::ostream& o)
	    {
		    o << "}\n";
	    }
    }  // namespace

    void serializer::Serialize(
		    const Vector<std::unique_ptr<TypeBase>>& types,
		    const Options& options)
    {
	    std::unique_ptr<std::ofstream> fout_hpp;
	    std::unique_ptr<std::ofstream> fout_cpp;
	    std::ostream* out_hpp = &std::cout;
	    std::ostream* out_cpp = &std::cout;

	    if (!options.out_hpp_path.empty())
	    {
		    fout_hpp = std::make_unique<std::ofstream>(options.out_hpp_path.c_str());
		    out_hpp = fout_hpp.get();
	    }

	    out_cpp = out_hpp;
	    if (!options.out_cpp_path.empty())
	    {
		    fout_cpp = std::make_unique<std::ofstream>(options.out_cpp_path.c_str());
		    out_cpp = fout_cpp.get();
	    }

      String defineMacroName = "DEFINE_";
      defineMacroName.append(options.internalLibName);
      defineMacroName.append("_TYPE");

      Map<String, uint32_t> typeNames;
      for (uint32_t typeIdx = 0; typeIdx < types.size(); ++typeIdx)
      {
        typeNames.insert(std::make_pair(types[typeIdx]->GetFullName(), typeIdx));
      }
      Vector<Set<uint32_t>> dependencies(types.size());
      Vector<Set<uint32_t>> dependents(types.size());

      bool noDependencies = true;

      for (uint32_t typeIdx = 0; typeIdx < types.size(); ++typeIdx)
      {
        auto& type = types[typeIdx];
        switch (type->GetType())
        {
        case TypeBase::Type::Enum:
          break;
        case TypeBase::Type::Function:
          for (auto& arg : static_cast<const Function&>(*type).m_Arguments)
          {

          }
          break;
        case TypeBase::Type::Class:
          for (auto& field : static_cast<const Class&>(*type).m_Fields)
          {
            for(auto& namesToLookFor : typeNames)
            {
              size_t foundName = field.type.find(namesToLookFor.first);
              if (foundName != String::npos)
              {
                size_t foundNameEnd = foundName + namesToLookFor.first.length();
                // Check if it's just part of another name.
                if ((foundName == 0 || !IsValidCIdentifierChar(field.type[foundName - 1]))
                  && (foundNameEnd == field.type.size() 
                    || !(field.type[foundNameEnd] == ':' || IsValidCIdentifierChar(field.type[foundNameEnd ]) )))
                {
                  // No self-dependency
                  assert(typeIdx != namesToLookFor.second);
                  // TODO : filter pointers and refs
                  dependencies[typeIdx].insert(namesToLookFor.second);
                  dependents[namesToLookFor.second].insert(typeIdx);
                  noDependencies = false;
                }
              }
            }
          }
          for (auto& field : static_cast<const Class&>(*type).m_StaticFields)
          {
            for (auto& namesToLookFor : typeNames)
            {
              size_t foundName = field.type.find(namesToLookFor.first);
              if (foundName != String::npos)
              {
                size_t foundNameEnd = foundName + namesToLookFor.first.length();
                // Check if it's just part of another name.
                if ((foundName == 0 || !IsValidCIdentifierChar(field.type[foundName - 1]))
                  && (foundNameEnd == field.type.size() 
                    || !(field.type[foundNameEnd] == ':' || IsValidCIdentifierChar(field.type[foundNameEnd]))) )
                {
                  // No self-dependency
                  assert(typeIdx != namesToLookFor.second);
                  // TODO : filter pointers and refs
                  dependencies[typeIdx].insert(namesToLookFor.second);
                  dependents[namesToLookFor.second].insert(typeIdx);
                  noDependencies = false;
                }
              }
            }
          }
          break;
        }
      }
      uint32_t curRank = 0;
      Vector<uint32_t> rank(types.size(), 0);
      
      while (!noDependencies)
      {
        assert(curRank <= types.size());
        noDependencies = true;
        for (uint32_t typeIdx = 0; typeIdx < types.size(); ++typeIdx)
        {
          if (rank[typeIdx] == curRank)
          {
            for (auto const& dep : dependents[typeIdx])
            {
              rank[dep] = curRank + 1;
              noDependencies = false;
            }
          }
        }
        ++curRank;
      }
      uint32_t const maxRank = curRank > 0 ? curRank : 1;
      Vector<uint32_t> order;
      for (curRank = 0; curRank < maxRank; ++curRank)
      {
        for (uint32_t typeIdx = 0; typeIdx < types.size(); ++typeIdx)
        {
          if (rank[typeIdx] == curRank)
          {
            order.push_back(typeIdx);
          }
        }
      }

	    BeginHeader(*out_hpp, options);
	    for (auto typeIdx : order)
	    {
        const auto& type = types[typeIdx];
		    switch (type->GetType())
		    {
		    case TypeBase::Type::Enum:
			    SerializeEnumHeader(*out_hpp, static_cast<const Enum&>(*type));
			    break;
		    case TypeBase::Type::Function:
			    SerializeFunctionHeader(*out_hpp, static_cast<const Function&>(*type));
			    break;
		    case TypeBase::Type::Class:
			    SerializeClassHeader(*out_hpp, static_cast<const Class&>(*type), "");
			    break;
		    }
		    *out_hpp << "\n\n";
	    }
	    EndHeader(*out_hpp, options);

	    BeginSources(*out_cpp, options, types);
      for (auto typeIdx : order)
      {
        const auto& type = types[typeIdx];
		    switch (type->GetType())
		    {
		    case TypeBase::Type::Enum:
			    SerializeEnumSources(*out_cpp, static_cast<const Enum&>(*type));
			    break;
		    case TypeBase::Type::Function:
			    SerializeFunctionSources(*out_cpp, static_cast<const Function&>(*type));
			    break;
		    case TypeBase::Type::Class:
			    SerializeClassSources(*out_cpp, static_cast<const Class&>(*type));
			    break;
		    }
		    *out_cpp << "\n\n";
	    }

#ifdef EXL_LUA
      String LuaRegFunName = "Register_";
      LuaRegFunName += options.internalLibName;
      LuaRegFunName += "_Lua";
      *out_cpp << "LUA_REG_FUN(" << LuaRegFunName << ");\n";
#endif

      *out_cpp << "void Register_" << options.internalLibName << "_Types()\n";
      *out_cpp << "{\n";

      for (auto typeIdx : order)
      {
        const auto& type = types[typeIdx];
        *out_cpp << "Register_" << GetNameWithoutColons(type->GetFullName()) << "_Type();" << "\n";
      }
#ifdef EXL_LUA
      *out_cpp << "LuaManager::AddRegFun(&" << LuaRegFunName << ");\n";
#endif

      *out_cpp << "}\n";

#ifdef EXL_LUA
      *out_cpp << "LUA_REG_FUN(" << LuaRegFunName << ")\n";
      *out_cpp << "{\n";

      for (auto typeIdx : order)
      {
        const auto& type = types[typeIdx];
        //if (type->GetType() == TypeBase::Type::Class)
        {
          *out_cpp << "Register_" << GetNameWithoutColons(type->GetFullName()) << "_Lua(iState);" << "\n";
        }
      }
      *out_cpp << "return 0;\n";
      *out_cpp << "}\n";
#endif

	    EndSources(*out_cpp);
    }
 }
}